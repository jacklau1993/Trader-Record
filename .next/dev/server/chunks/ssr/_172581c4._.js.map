{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///Users/jacklau/Documents/GitHub/Trading-app/components/ui/card.tsx"],"sourcesContent":["import * as React from \"react\";\nimport { cn } from \"@/lib/utils\";\n\nconst Card = React.forwardRef<HTMLDivElement, React.HTMLAttributes<HTMLDivElement>>(\n    ({ className, ...props }, ref) => (\n        <div\n            ref={ref}\n            className={cn(\"rounded-xl border border-border bg-card text-card-foreground shadow-sm\", className)}\n            {...props}\n        />\n    )\n);\nCard.displayName = \"Card\";\n\nconst CardHeader = React.forwardRef<HTMLDivElement, React.HTMLAttributes<HTMLDivElement>>(\n    ({ className, ...props }, ref) => (\n        <div ref={ref} className={cn(\"flex flex-col space-y-1.5 p-6\", className)} {...props} />\n    )\n);\nCardHeader.displayName = \"CardHeader\";\n\nconst CardTitle = React.forwardRef<HTMLParagraphElement, React.HTMLAttributes<HTMLHeadingElement>>(\n    ({ className, ...props }, ref) => (\n        <h3 ref={ref} className={cn(\"font-semibold leading-none tracking-tight\", className)} {...props} />\n    )\n);\nCardTitle.displayName = \"CardTitle\";\n\nconst CardDescription = React.forwardRef<HTMLParagraphElement, React.HTMLAttributes<HTMLParagraphElement>>(\n    ({ className, ...props }, ref) => (\n        <p\n            ref={ref}\n            className={cn(\"text-sm text-muted-foreground\", className)}\n            {...props}\n        />\n    )\n);\nCardDescription.displayName = \"CardDescription\";\n\nconst CardContent = React.forwardRef<HTMLDivElement, React.HTMLAttributes<HTMLDivElement>>(\n    ({ className, ...props }, ref) => (\n        <div ref={ref} className={cn(\"p-6 pt-0\", className)} {...props} />\n    )\n);\nCardContent.displayName = \"CardContent\";\n\nexport { Card, CardHeader, CardTitle, CardDescription, CardContent };\n"],"names":[],"mappings":";;;;;;;;;;;;;AAAA;AACA;;;;AAEA,MAAM,qBAAO,mNAAgB,CACzB,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBACtB,8OAAC;QACG,KAAK;QACL,WAAW,IAAA,kHAAE,EAAC,0EAA0E;QACvF,GAAG,KAAK;;;;;;AAIrB,KAAK,WAAW,GAAG;AAEnB,MAAM,2BAAa,mNAAgB,CAC/B,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBACtB,8OAAC;QAAI,KAAK;QAAK,WAAW,IAAA,kHAAE,EAAC,iCAAiC;QAAa,GAAG,KAAK;;;;;;AAG3F,WAAW,WAAW,GAAG;AAEzB,MAAM,0BAAY,mNAAgB,CAC9B,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBACtB,8OAAC;QAAG,KAAK;QAAK,WAAW,IAAA,kHAAE,EAAC,6CAA6C;QAAa,GAAG,KAAK;;;;;;AAGtG,UAAU,WAAW,GAAG;AAExB,MAAM,gCAAkB,mNAAgB,CACpC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBACtB,8OAAC;QACG,KAAK;QACL,WAAW,IAAA,kHAAE,EAAC,iCAAiC;QAC9C,GAAG,KAAK;;;;;;AAIrB,gBAAgB,WAAW,GAAG;AAE9B,MAAM,4BAAc,mNAAgB,CAChC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBACtB,8OAAC;QAAI,KAAK;QAAK,WAAW,IAAA,kHAAE,EAAC,YAAY;QAAa,GAAG,KAAK;;;;;;AAGtE,YAAY,WAAW,GAAG"}},
    {"offset": {"line": 77, "column": 0}, "map": {"version":3,"sources":["file:///Users/jacklau/Documents/GitHub/Trading-app/app/actions/tag-actions.ts"],"sourcesContent":["\"use server\";\n\nimport { auth } from \"@/lib/auth\";\nimport { headers } from \"next/headers\";\nimport { getDb } from \"@/lib/db\";\nimport { categories, tags } from \"@/db/schema\";\nimport { eq, and } from \"drizzle-orm\";\nimport { revalidatePath } from \"next/cache\";\n\nasync function getUser() {\n    const session = await auth.api.getSession({\n        headers: await headers()\n    });\n    if (!session?.user) throw new Error(\"Unauthorized\");\n    return session.user;\n}\n\n// --- Categories ---\nexport async function getCategories() {\n    const user = await getUser();\n    const db = getDb();\n\n    // Fetch categories and their tags\n    // Drizzle doesn't do deep nesting automatically easily without `with` query which requires relations defined.\n    // For simplicity, we'll fetch both and assemble in JS, or use a join.\n    // Let's fetch all categories for user\n    const userCats = await db.select().from(categories).where(eq(categories.userId, user.id));\n    const userTags = await db.select().from(tags).where(eq(tags.userId, user.id));\n\n    // Assemble\n    return userCats.map(cat => ({\n        ...cat,\n        tags: userTags.filter(t => t.categoryId === cat.id)\n    }));\n}\n\nexport async function createCategory(data: Omit<typeof categories.$inferInsert, \"userId\">) {\n    const user = await getUser();\n    const db = getDb();\n\n    await db.insert(categories).values({\n        ...data,\n        userId: user.id\n    });\n\n    revalidatePath(\"/tags\");\n    revalidatePath(\"/reports\");\n    return { success: true };\n}\n\nexport async function deleteCategory(id: string) {\n    const user = await getUser();\n    const db = getDb();\n\n    await db.delete(categories).where(and(eq(categories.id, id), eq(categories.userId, user.id)));\n    revalidatePath(\"/tags\");\n    return { success: true };\n}\n\nexport async function updateCategory(id: string, data: Partial<typeof categories.$inferInsert>) {\n    const user = await getUser();\n    const db = getDb();\n\n    await db.update(categories)\n        .set({ ...data, updatedAt: new Date() })\n        .where(and(eq(categories.id, id), eq(categories.userId, user.id)));\n\n    // If color changed, update tags? The current logic does that in UI, \n    // but in DB we might want to cascade or keep them separate.\n    // The previous app logic updated all tags.\n    if (data.color) {\n        await db.update(tags)\n            .set({ color: data.color }) // We might need to adjust formatting if color logic changes\n            .where(and(eq(tags.categoryId, id), eq(tags.userId, user.id)));\n    }\n\n    revalidatePath(\"/tags\");\n    return { success: true };\n}\n\n// --- Tags ---\nexport async function createTag(data: Omit<typeof tags.$inferInsert, \"userId\">) {\n    const user = await getUser();\n    const db = getDb();\n\n    await db.insert(tags).values({\n        ...data,\n        userId: user.id\n    });\n\n    revalidatePath(\"/tags\");\n    return { success: true };\n}\n\nexport async function deleteTag(id: string) {\n    const user = await getUser();\n    const db = getDb();\n\n    await db.delete(tags).where(and(eq(tags.id, id), eq(tags.userId, user.id)));\n    revalidatePath(\"/tags\");\n    return { success: true };\n}\n"],"names":[],"mappings":";;;;;;;IAoCsB,iBAAA,WAAA,GAAA,IAAA,+OAAA,EAAA,8CAAA,oOAAA,EAAA,KAAA,GAAA,0OAAA,EAAA"}},
    {"offset": {"line": 89, "column": 0}, "map": {"version":3,"sources":["file:///Users/jacklau/Documents/GitHub/Trading-app/app/actions/tag-actions.ts"],"sourcesContent":["\"use server\";\n\nimport { auth } from \"@/lib/auth\";\nimport { headers } from \"next/headers\";\nimport { getDb } from \"@/lib/db\";\nimport { categories, tags } from \"@/db/schema\";\nimport { eq, and } from \"drizzle-orm\";\nimport { revalidatePath } from \"next/cache\";\n\nasync function getUser() {\n    const session = await auth.api.getSession({\n        headers: await headers()\n    });\n    if (!session?.user) throw new Error(\"Unauthorized\");\n    return session.user;\n}\n\n// --- Categories ---\nexport async function getCategories() {\n    const user = await getUser();\n    const db = getDb();\n\n    // Fetch categories and their tags\n    // Drizzle doesn't do deep nesting automatically easily without `with` query which requires relations defined.\n    // For simplicity, we'll fetch both and assemble in JS, or use a join.\n    // Let's fetch all categories for user\n    const userCats = await db.select().from(categories).where(eq(categories.userId, user.id));\n    const userTags = await db.select().from(tags).where(eq(tags.userId, user.id));\n\n    // Assemble\n    return userCats.map(cat => ({\n        ...cat,\n        tags: userTags.filter(t => t.categoryId === cat.id)\n    }));\n}\n\nexport async function createCategory(data: Omit<typeof categories.$inferInsert, \"userId\">) {\n    const user = await getUser();\n    const db = getDb();\n\n    await db.insert(categories).values({\n        ...data,\n        userId: user.id\n    });\n\n    revalidatePath(\"/tags\");\n    revalidatePath(\"/reports\");\n    return { success: true };\n}\n\nexport async function deleteCategory(id: string) {\n    const user = await getUser();\n    const db = getDb();\n\n    await db.delete(categories).where(and(eq(categories.id, id), eq(categories.userId, user.id)));\n    revalidatePath(\"/tags\");\n    return { success: true };\n}\n\nexport async function updateCategory(id: string, data: Partial<typeof categories.$inferInsert>) {\n    const user = await getUser();\n    const db = getDb();\n\n    await db.update(categories)\n        .set({ ...data, updatedAt: new Date() })\n        .where(and(eq(categories.id, id), eq(categories.userId, user.id)));\n\n    // If color changed, update tags? The current logic does that in UI, \n    // but in DB we might want to cascade or keep them separate.\n    // The previous app logic updated all tags.\n    if (data.color) {\n        await db.update(tags)\n            .set({ color: data.color }) // We might need to adjust formatting if color logic changes\n            .where(and(eq(tags.categoryId, id), eq(tags.userId, user.id)));\n    }\n\n    revalidatePath(\"/tags\");\n    return { success: true };\n}\n\n// --- Tags ---\nexport async function createTag(data: Omit<typeof tags.$inferInsert, \"userId\">) {\n    const user = await getUser();\n    const db = getDb();\n\n    await db.insert(tags).values({\n        ...data,\n        userId: user.id\n    });\n\n    revalidatePath(\"/tags\");\n    return { success: true };\n}\n\nexport async function deleteTag(id: string) {\n    const user = await getUser();\n    const db = getDb();\n\n    await db.delete(tags).where(and(eq(tags.id, id), eq(tags.userId, user.id)));\n    revalidatePath(\"/tags\");\n    return { success: true };\n}\n"],"names":[],"mappings":";;;;;;;IAkDsB,iBAAA,WAAA,GAAA,IAAA,+OAAA,EAAA,8CAAA,oOAAA,EAAA,KAAA,GAAA,0OAAA,EAAA"}},
    {"offset": {"line": 101, "column": 0}, "map": {"version":3,"sources":["file:///Users/jacklau/Documents/GitHub/Trading-app/app/actions/tag-actions.ts"],"sourcesContent":["\"use server\";\n\nimport { auth } from \"@/lib/auth\";\nimport { headers } from \"next/headers\";\nimport { getDb } from \"@/lib/db\";\nimport { categories, tags } from \"@/db/schema\";\nimport { eq, and } from \"drizzle-orm\";\nimport { revalidatePath } from \"next/cache\";\n\nasync function getUser() {\n    const session = await auth.api.getSession({\n        headers: await headers()\n    });\n    if (!session?.user) throw new Error(\"Unauthorized\");\n    return session.user;\n}\n\n// --- Categories ---\nexport async function getCategories() {\n    const user = await getUser();\n    const db = getDb();\n\n    // Fetch categories and their tags\n    // Drizzle doesn't do deep nesting automatically easily without `with` query which requires relations defined.\n    // For simplicity, we'll fetch both and assemble in JS, or use a join.\n    // Let's fetch all categories for user\n    const userCats = await db.select().from(categories).where(eq(categories.userId, user.id));\n    const userTags = await db.select().from(tags).where(eq(tags.userId, user.id));\n\n    // Assemble\n    return userCats.map(cat => ({\n        ...cat,\n        tags: userTags.filter(t => t.categoryId === cat.id)\n    }));\n}\n\nexport async function createCategory(data: Omit<typeof categories.$inferInsert, \"userId\">) {\n    const user = await getUser();\n    const db = getDb();\n\n    await db.insert(categories).values({\n        ...data,\n        userId: user.id\n    });\n\n    revalidatePath(\"/tags\");\n    revalidatePath(\"/reports\");\n    return { success: true };\n}\n\nexport async function deleteCategory(id: string) {\n    const user = await getUser();\n    const db = getDb();\n\n    await db.delete(categories).where(and(eq(categories.id, id), eq(categories.userId, user.id)));\n    revalidatePath(\"/tags\");\n    return { success: true };\n}\n\nexport async function updateCategory(id: string, data: Partial<typeof categories.$inferInsert>) {\n    const user = await getUser();\n    const db = getDb();\n\n    await db.update(categories)\n        .set({ ...data, updatedAt: new Date() })\n        .where(and(eq(categories.id, id), eq(categories.userId, user.id)));\n\n    // If color changed, update tags? The current logic does that in UI, \n    // but in DB we might want to cascade or keep them separate.\n    // The previous app logic updated all tags.\n    if (data.color) {\n        await db.update(tags)\n            .set({ color: data.color }) // We might need to adjust formatting if color logic changes\n            .where(and(eq(tags.categoryId, id), eq(tags.userId, user.id)));\n    }\n\n    revalidatePath(\"/tags\");\n    return { success: true };\n}\n\n// --- Tags ---\nexport async function createTag(data: Omit<typeof tags.$inferInsert, \"userId\">) {\n    const user = await getUser();\n    const db = getDb();\n\n    await db.insert(tags).values({\n        ...data,\n        userId: user.id\n    });\n\n    revalidatePath(\"/tags\");\n    return { success: true };\n}\n\nexport async function deleteTag(id: string) {\n    const user = await getUser();\n    const db = getDb();\n\n    await db.delete(tags).where(and(eq(tags.id, id), eq(tags.userId, user.id)));\n    revalidatePath(\"/tags\");\n    return { success: true };\n}\n"],"names":[],"mappings":";;;;;;;IA2DsB,iBAAA,WAAA,GAAA,IAAA,+OAAA,EAAA,8CAAA,oOAAA,EAAA,KAAA,GAAA,0OAAA,EAAA"}},
    {"offset": {"line": 113, "column": 0}, "map": {"version":3,"sources":["file:///Users/jacklau/Documents/GitHub/Trading-app/app/actions/tag-actions.ts"],"sourcesContent":["\"use server\";\n\nimport { auth } from \"@/lib/auth\";\nimport { headers } from \"next/headers\";\nimport { getDb } from \"@/lib/db\";\nimport { categories, tags } from \"@/db/schema\";\nimport { eq, and } from \"drizzle-orm\";\nimport { revalidatePath } from \"next/cache\";\n\nasync function getUser() {\n    const session = await auth.api.getSession({\n        headers: await headers()\n    });\n    if (!session?.user) throw new Error(\"Unauthorized\");\n    return session.user;\n}\n\n// --- Categories ---\nexport async function getCategories() {\n    const user = await getUser();\n    const db = getDb();\n\n    // Fetch categories and their tags\n    // Drizzle doesn't do deep nesting automatically easily without `with` query which requires relations defined.\n    // For simplicity, we'll fetch both and assemble in JS, or use a join.\n    // Let's fetch all categories for user\n    const userCats = await db.select().from(categories).where(eq(categories.userId, user.id));\n    const userTags = await db.select().from(tags).where(eq(tags.userId, user.id));\n\n    // Assemble\n    return userCats.map(cat => ({\n        ...cat,\n        tags: userTags.filter(t => t.categoryId === cat.id)\n    }));\n}\n\nexport async function createCategory(data: Omit<typeof categories.$inferInsert, \"userId\">) {\n    const user = await getUser();\n    const db = getDb();\n\n    await db.insert(categories).values({\n        ...data,\n        userId: user.id\n    });\n\n    revalidatePath(\"/tags\");\n    revalidatePath(\"/reports\");\n    return { success: true };\n}\n\nexport async function deleteCategory(id: string) {\n    const user = await getUser();\n    const db = getDb();\n\n    await db.delete(categories).where(and(eq(categories.id, id), eq(categories.userId, user.id)));\n    revalidatePath(\"/tags\");\n    return { success: true };\n}\n\nexport async function updateCategory(id: string, data: Partial<typeof categories.$inferInsert>) {\n    const user = await getUser();\n    const db = getDb();\n\n    await db.update(categories)\n        .set({ ...data, updatedAt: new Date() })\n        .where(and(eq(categories.id, id), eq(categories.userId, user.id)));\n\n    // If color changed, update tags? The current logic does that in UI, \n    // but in DB we might want to cascade or keep them separate.\n    // The previous app logic updated all tags.\n    if (data.color) {\n        await db.update(tags)\n            .set({ color: data.color }) // We might need to adjust formatting if color logic changes\n            .where(and(eq(tags.categoryId, id), eq(tags.userId, user.id)));\n    }\n\n    revalidatePath(\"/tags\");\n    return { success: true };\n}\n\n// --- Tags ---\nexport async function createTag(data: Omit<typeof tags.$inferInsert, \"userId\">) {\n    const user = await getUser();\n    const db = getDb();\n\n    await db.insert(tags).values({\n        ...data,\n        userId: user.id\n    });\n\n    revalidatePath(\"/tags\");\n    return { success: true };\n}\n\nexport async function deleteTag(id: string) {\n    const user = await getUser();\n    const db = getDb();\n\n    await db.delete(tags).where(and(eq(tags.id, id), eq(tags.userId, user.id)));\n    revalidatePath(\"/tags\");\n    return { success: true };\n}\n"],"names":[],"mappings":";;;;;;;IAiFsB,YAAA,WAAA,GAAA,IAAA,+OAAA,EAAA,8CAAA,oOAAA,EAAA,KAAA,GAAA,0OAAA,EAAA"}},
    {"offset": {"line": 125, "column": 0}, "map": {"version":3,"sources":["file:///Users/jacklau/Documents/GitHub/Trading-app/app/actions/tag-actions.ts"],"sourcesContent":["\"use server\";\n\nimport { auth } from \"@/lib/auth\";\nimport { headers } from \"next/headers\";\nimport { getDb } from \"@/lib/db\";\nimport { categories, tags } from \"@/db/schema\";\nimport { eq, and } from \"drizzle-orm\";\nimport { revalidatePath } from \"next/cache\";\n\nasync function getUser() {\n    const session = await auth.api.getSession({\n        headers: await headers()\n    });\n    if (!session?.user) throw new Error(\"Unauthorized\");\n    return session.user;\n}\n\n// --- Categories ---\nexport async function getCategories() {\n    const user = await getUser();\n    const db = getDb();\n\n    // Fetch categories and their tags\n    // Drizzle doesn't do deep nesting automatically easily without `with` query which requires relations defined.\n    // For simplicity, we'll fetch both and assemble in JS, or use a join.\n    // Let's fetch all categories for user\n    const userCats = await db.select().from(categories).where(eq(categories.userId, user.id));\n    const userTags = await db.select().from(tags).where(eq(tags.userId, user.id));\n\n    // Assemble\n    return userCats.map(cat => ({\n        ...cat,\n        tags: userTags.filter(t => t.categoryId === cat.id)\n    }));\n}\n\nexport async function createCategory(data: Omit<typeof categories.$inferInsert, \"userId\">) {\n    const user = await getUser();\n    const db = getDb();\n\n    await db.insert(categories).values({\n        ...data,\n        userId: user.id\n    });\n\n    revalidatePath(\"/tags\");\n    revalidatePath(\"/reports\");\n    return { success: true };\n}\n\nexport async function deleteCategory(id: string) {\n    const user = await getUser();\n    const db = getDb();\n\n    await db.delete(categories).where(and(eq(categories.id, id), eq(categories.userId, user.id)));\n    revalidatePath(\"/tags\");\n    return { success: true };\n}\n\nexport async function updateCategory(id: string, data: Partial<typeof categories.$inferInsert>) {\n    const user = await getUser();\n    const db = getDb();\n\n    await db.update(categories)\n        .set({ ...data, updatedAt: new Date() })\n        .where(and(eq(categories.id, id), eq(categories.userId, user.id)));\n\n    // If color changed, update tags? The current logic does that in UI, \n    // but in DB we might want to cascade or keep them separate.\n    // The previous app logic updated all tags.\n    if (data.color) {\n        await db.update(tags)\n            .set({ color: data.color }) // We might need to adjust formatting if color logic changes\n            .where(and(eq(tags.categoryId, id), eq(tags.userId, user.id)));\n    }\n\n    revalidatePath(\"/tags\");\n    return { success: true };\n}\n\n// --- Tags ---\nexport async function createTag(data: Omit<typeof tags.$inferInsert, \"userId\">) {\n    const user = await getUser();\n    const db = getDb();\n\n    await db.insert(tags).values({\n        ...data,\n        userId: user.id\n    });\n\n    revalidatePath(\"/tags\");\n    return { success: true };\n}\n\nexport async function deleteTag(id: string) {\n    const user = await getUser();\n    const db = getDb();\n\n    await db.delete(tags).where(and(eq(tags.id, id), eq(tags.userId, user.id)));\n    revalidatePath(\"/tags\");\n    return { success: true };\n}\n"],"names":[],"mappings":";;;;;;;IA8FsB,YAAA,WAAA,GAAA,IAAA,+OAAA,EAAA,8CAAA,oOAAA,EAAA,KAAA,GAAA,0OAAA,EAAA"}},
    {"offset": {"line": 137, "column": 0}, "map": {"version":3,"sources":["file:///Users/jacklau/Documents/GitHub/Trading-app/components/tags/TagsClient.tsx"],"sourcesContent":["\"use client\";\n\nimport { useState, useEffect } from \"react\";\nimport { Plus, X, Tag as TagIcon, FolderPlus, Palette } from \"lucide-react\";\nimport { Card, CardHeader, CardTitle, CardContent } from \"@/components/ui/card\";\nimport { useRouter } from \"next/navigation\";\nimport { createCategory, deleteCategory, updateCategory, createTag, deleteTag } from \"@/app/actions/tag-actions\";\n\n// Types\ninterface Tag {\n    id: string;\n    categoryId: string;\n    name: string;\n    color: string;\n}\n\ninterface Category {\n    id: string;\n    name: string;\n    color: string;\n    tags: Tag[];\n}\n\nconst COLORS = [\n    { name: \"Blue\", value: \"blue\", class: \"text-blue-500 bg-blue-500/10\", border: \"border-blue-500/20\" },\n    { name: \"Green\", value: \"green\", class: \"text-green-500 bg-green-500/10\", border: \"border-green-500/20\" },\n    { name: \"Red\", value: \"red\", class: \"text-red-500 bg-red-500/10\", border: \"border-red-500/20\" },\n    { name: \"Yellow\", value: \"yellow\", class: \"text-yellow-500 bg-yellow-500/10\", border: \"border-yellow-500/20\" },\n    { name: \"Purple\", value: \"purple\", class: \"text-purple-500 bg-purple-500/10\", border: \"border-purple-500/20\" },\n    { name: \"Orange\", value: \"orange\", class: \"text-orange-500 bg-orange-500/10\", border: \"border-orange-500/20\" },\n    { name: \"Pink\", value: \"pink\", class: \"text-pink-500 bg-pink-500/10\", border: \"border-pink-500/20\" },\n    { name: \"Gray\", value: \"gray\", class: \"text-gray-500 bg-gray-500/10\", border: \"border-gray-500/20\" },\n];\n\nexport default function TagsClient({ initialCategories }: { initialCategories: any[] }) {\n    const [categories, setCategories] = useState<Category[]>(initialCategories);\n    const [newCatName, setNewCatName] = useState(\"\");\n    const [selectedColor, setSelectedColor] = useState(\"blue\");\n    const [newTagNames, setNewTagNames] = useState<Record<string, string>>({});\n    const [updating, setUpdating] = useState(false);\n    const router = useRouter();\n\n    useEffect(() => {\n        setCategories(initialCategories);\n    }, [initialCategories]);\n\n    const handleAddCategory = async () => {\n        if (!newCatName.trim()) return;\n        setUpdating(true);\n        const id = `cat_${Date.now()}`;\n\n        // Optimistic update\n        const newCat: Category = {\n            id,\n            name: newCatName,\n            color: selectedColor,\n            tags: []\n        };\n        setCategories([...categories, newCat]);\n        setNewCatName(\"\");\n\n        try {\n            await createCategory({\n                id,\n                name: newCatName,\n                color: selectedColor\n            });\n            router.refresh();\n        } catch (error) {\n            console.error(error);\n            // Revert on error? For now simple log.\n        } finally {\n            setUpdating(false);\n        }\n    };\n\n    const handleDeleteCategory = async (catId: string) => {\n        if (!confirm(\"Are you sure? This will delete all tags in this category.\")) return;\n        setUpdating(true);\n        setCategories(categories.filter(c => c.id !== catId));\n\n        try {\n            await deleteCategory(catId);\n            router.refresh();\n        } catch (error) { console.error(error); } finally { setUpdating(false); }\n    };\n\n    const handleUpdateCategoryColor = async (catId: string, color: string) => {\n        const cat = categories.find(c => c.id === catId);\n        if (!cat || cat.color === color) return;\n\n        setCategories(categories.map(c => c.id === catId ? { ...c, color } : c));\n\n        try {\n            await updateCategory(catId, { color });\n            router.refresh();\n        } catch (error) { console.error(error); }\n    };\n\n    const handleAddTag = async (catId: string) => {\n        const tagName = newTagNames[catId];\n        if (!tagName?.trim()) return;\n        setUpdating(true);\n\n        const id = `tag_${Date.now()}`;\n        const cat = categories.find(c => c.id === catId);\n        const colorObj = COLORS.find(c => c.value === (cat?.color || \"blue\")) || COLORS[0];\n\n        // Optimistic\n        setCategories(categories.map(c => {\n            if (c.id === catId) {\n                return { ...c, tags: [...c.tags, { id, categoryId: catId, name: tagName, color: colorObj.class }] };\n            }\n            return c;\n        }));\n        setNewTagNames(prev => ({ ...prev, [catId]: \"\" }));\n\n        try {\n            await createTag({\n                id,\n                categoryId: catId,\n                name: tagName,\n                color: colorObj.class\n            });\n            router.refresh();\n        } catch (error) { console.error(error); } finally { setUpdating(false); }\n    };\n\n    const handleDeleteTag = async (catId: string, tagId: string) => {\n        setCategories(categories.map(c => {\n            if (c.id === catId) {\n                return { ...c, tags: c.tags.filter(t => t.id !== tagId) };\n            }\n            return c;\n        }));\n\n        try {\n            await deleteTag(tagId);\n            router.refresh();\n        } catch (error) { console.error(error); }\n    };\n\n    return (\n        <div className=\"flex-1 space-y-4 p-8 pt-6\">\n            <div className=\"flex items-center justify-between\">\n                <h2 className=\"text-3xl font-bold tracking-tight\">Tag Management</h2>\n\n                <div className=\"flex items-center space-x-2 bg-muted/30 p-1 rounded-lg border border-border\">\n                    <input\n                        type=\"text\"\n                        placeholder=\"New Category Name\"\n                        className=\"bg-transparent border-none px-3 py-1.5 text-sm w-48 focus:outline-none\"\n                        value={newCatName}\n                        onChange={(e) => setNewCatName(e.target.value)}\n                        onKeyDown={(e) => e.key === 'Enter' && handleAddCategory()}\n                    />\n\n                    {/* Color Picker for New Category */}\n                    <div className=\"flex space-x-1 px-2 border-l border-border\">\n                        {COLORS.slice(0, 5).map(c => (\n                            <button\n                                key={c.value}\n                                onClick={() => setSelectedColor(c.value)}\n                                className={`w-4 h-4 rounded-full transition-transform hover:scale-110 ${c.value === selectedColor ? 'ring-2 ring-primary ring-offset-1' : ''}`}\n                                style={{ backgroundColor: c.value === 'white' ? 'white' : `var(--color-${c.value}-500, ${c.value})` }}\n                                title={c.name}\n                            />\n                        ))}\n                    </div>\n\n                    <button\n                        onClick={handleAddCategory}\n                        disabled={updating}\n                        className=\"bg-primary text-primary-foreground hover:bg-primary/90 px-3 py-1.5 rounded-md text-xs font-medium ml-2 disabled:opacity-50\"\n                    >\n                        Add\n                    </button>\n                </div>\n            </div>\n\n            <div className=\"grid gap-4 md:grid-cols-2 lg:grid-cols-3\">\n                {categories.map((category) => {\n                    const catColor = COLORS.find(c => c.value === category.color) || COLORS[0];\n                    return (\n                        <Card key={category.id} className={`relative group border-t-4 ${catColor?.border ? catColor.border.replace('border-', 'border-t-') : ''}`} style={{ borderTopColor: category.color !== 'white' ? category.color : undefined }}>\n                            <CardHeader className=\"pb-3 flex flex-row items-center justify-between space-y-0\">\n                                <div className=\"flex items-center space-x-2\">\n                                    <CardTitle>{category.name}</CardTitle>\n                                    <div className=\"flex space-x-1\">\n                                        {COLORS.map(c => (\n                                            <button\n                                                key={c.value}\n                                                onClick={() => handleUpdateCategoryColor(category.id, c.value)}\n                                                className={`w-3 h-3 rounded-full transition-transform hover:scale-125 ${category.color === c.value ? 'ring-2 ring-offset-1 ring-primary' : ''}`}\n                                                style={{ backgroundColor: c.value === 'white' ? '#e2e8f0' : `var(--color-${c.value}-500, ${c.value})` }}\n                                                title={`Set color to ${c.name}`}\n                                            />\n                                        ))}\n                                    </div>\n                                </div>\n                                <button\n                                    onClick={() => handleDeleteCategory(category.id)}\n                                    className=\"text-muted-foreground hover:text-destructive opacity-0 group-hover:opacity-100 transition-opacity\"\n                                >\n                                    <X className=\"h-4 w-4\" />\n                                </button>\n                            </CardHeader>\n                            <CardContent>\n                                <div className=\"flex flex-wrap gap-2 mb-4\">\n                                    {category.tags.map(tag => (\n                                        <div key={tag.id} className={`flex items-center space-x-1 px-2 py-1 rounded-md text-xs font-medium ${tag.color || catColor.class}`}>\n                                            <span>{tag.name}</span>\n                                            <button onClick={() => handleDeleteTag(category.id, tag.id)} className=\"hover:text-foreground/70 ml-1\">\n                                                <X className=\"h-3 w-3\" />\n                                            </button>\n                                        </div>\n                                    ))}\n                                    {category.tags.length === 0 && (\n                                        <span className=\"text-xs text-muted-foreground italic\">No tags yet</span>\n                                    )}\n                                </div>\n\n                                <div className=\"flex items-center space-x-2 mt-2\">\n                                    <input\n                                        type=\"text\"\n                                        placeholder=\"Add tag...\"\n                                        className=\"flex-1 bg-muted/50 border-none text-xs px-2 py-1.5 rounded focus:outline-none focus:ring-1 focus:ring-primary\"\n                                        value={newTagNames[category.id] || \"\"}\n                                        onChange={(e) => setNewTagNames(prev => ({ ...prev, [category.id]: e.target.value }))}\n                                        onKeyDown={(e) => e.key === 'Enter' && handleAddTag(category.id)}\n                                    />\n                                    <button\n                                        onClick={() => handleAddTag(category.id)}\n                                        className=\"p-1.5 hover:bg-muted rounded text-primary\"\n                                    >\n                                        <Plus className=\"h-3 w-3\" />\n                                    </button>\n                                </div>\n                            </CardContent>\n                        </Card>\n                    );\n                })}\n            </div>\n        </div>\n    );\n}\n"],"names":[],"mappings":";;;;;AAEA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AANA;;;;;;;AAuBA,MAAM,SAAS;IACX;QAAE,MAAM;QAAQ,OAAO;QAAQ,OAAO;QAAgC,QAAQ;IAAqB;IACnG;QAAE,MAAM;QAAS,OAAO;QAAS,OAAO;QAAkC,QAAQ;IAAsB;IACxG;QAAE,MAAM;QAAO,OAAO;QAAO,OAAO;QAA8B,QAAQ;IAAoB;IAC9F;QAAE,MAAM;QAAU,OAAO;QAAU,OAAO;QAAoC,QAAQ;IAAuB;IAC7G;QAAE,MAAM;QAAU,OAAO;QAAU,OAAO;QAAoC,QAAQ;IAAuB;IAC7G;QAAE,MAAM;QAAU,OAAO;QAAU,OAAO;QAAoC,QAAQ;IAAuB;IAC7G;QAAE,MAAM;QAAQ,OAAO;QAAQ,OAAO;QAAgC,QAAQ;IAAqB;IACnG;QAAE,MAAM;QAAQ,OAAO;QAAQ,OAAO;QAAgC,QAAQ;IAAqB;CACtG;AAEc,SAAS,WAAW,EAAE,iBAAiB,EAAgC;IAClF,MAAM,CAAC,YAAY,cAAc,GAAG,IAAA,iNAAQ,EAAa;IACzD,MAAM,CAAC,YAAY,cAAc,GAAG,IAAA,iNAAQ,EAAC;IAC7C,MAAM,CAAC,eAAe,iBAAiB,GAAG,IAAA,iNAAQ,EAAC;IACnD,MAAM,CAAC,aAAa,eAAe,GAAG,IAAA,iNAAQ,EAAyB,CAAC;IACxE,MAAM,CAAC,UAAU,YAAY,GAAG,IAAA,iNAAQ,EAAC;IACzC,MAAM,SAAS,IAAA,+IAAS;IAExB,IAAA,kNAAS,EAAC;QACN,cAAc;IAClB,GAAG;QAAC;KAAkB;IAEtB,MAAM,oBAAoB;QACtB,IAAI,CAAC,WAAW,IAAI,IAAI;QACxB,YAAY;QACZ,MAAM,KAAK,CAAC,IAAI,EAAE,KAAK,GAAG,IAAI;QAE9B,oBAAoB;QACpB,MAAM,SAAmB;YACrB;YACA,MAAM;YACN,OAAO;YACP,MAAM,EAAE;QACZ;QACA,cAAc;eAAI;YAAY;SAAO;QACrC,cAAc;QAEd,IAAI;YACA,MAAM,IAAA,wKAAc,EAAC;gBACjB;gBACA,MAAM;gBACN,OAAO;YACX;YACA,OAAO,OAAO;QAClB,EAAE,OAAO,OAAO;YACZ,QAAQ,KAAK,CAAC;QACd,uCAAuC;QAC3C,SAAU;YACN,YAAY;QAChB;IACJ;IAEA,MAAM,uBAAuB,OAAO;QAChC,IAAI,CAAC,QAAQ,8DAA8D;QAC3E,YAAY;QACZ,cAAc,WAAW,MAAM,CAAC,CAAA,IAAK,EAAE,EAAE,KAAK;QAE9C,IAAI;YACA,MAAM,IAAA,wKAAc,EAAC;YACrB,OAAO,OAAO;QAClB,EAAE,OAAO,OAAO;YAAE,QAAQ,KAAK,CAAC;QAAQ,SAAU;YAAE,YAAY;QAAQ;IAC5E;IAEA,MAAM,4BAA4B,OAAO,OAAe;QACpD,MAAM,MAAM,WAAW,IAAI,CAAC,CAAA,IAAK,EAAE,EAAE,KAAK;QAC1C,IAAI,CAAC,OAAO,IAAI,KAAK,KAAK,OAAO;QAEjC,cAAc,WAAW,GAAG,CAAC,CAAA,IAAK,EAAE,EAAE,KAAK,QAAQ;gBAAE,GAAG,CAAC;gBAAE;YAAM,IAAI;QAErE,IAAI;YACA,MAAM,IAAA,wKAAc,EAAC,OAAO;gBAAE;YAAM;YACpC,OAAO,OAAO;QAClB,EAAE,OAAO,OAAO;YAAE,QAAQ,KAAK,CAAC;QAAQ;IAC5C;IAEA,MAAM,eAAe,OAAO;QACxB,MAAM,UAAU,WAAW,CAAC,MAAM;QAClC,IAAI,CAAC,SAAS,QAAQ;QACtB,YAAY;QAEZ,MAAM,KAAK,CAAC,IAAI,EAAE,KAAK,GAAG,IAAI;QAC9B,MAAM,MAAM,WAAW,IAAI,CAAC,CAAA,IAAK,EAAE,EAAE,KAAK;QAC1C,MAAM,WAAW,OAAO,IAAI,CAAC,CAAA,IAAK,EAAE,KAAK,KAAK,CAAC,KAAK,SAAS,MAAM,MAAM,MAAM,CAAC,EAAE;QAElF,aAAa;QACb,cAAc,WAAW,GAAG,CAAC,CAAA;YACzB,IAAI,EAAE,EAAE,KAAK,OAAO;gBAChB,OAAO;oBAAE,GAAG,CAAC;oBAAE,MAAM;2BAAI,EAAE,IAAI;wBAAE;4BAAE;4BAAI,YAAY;4BAAO,MAAM;4BAAS,OAAO,SAAS,KAAK;wBAAC;qBAAE;gBAAC;YACtG;YACA,OAAO;QACX;QACA,eAAe,CAAA,OAAQ,CAAC;gBAAE,GAAG,IAAI;gBAAE,CAAC,MAAM,EAAE;YAAG,CAAC;QAEhD,IAAI;YACA,MAAM,IAAA,mKAAS,EAAC;gBACZ;gBACA,YAAY;gBACZ,MAAM;gBACN,OAAO,SAAS,KAAK;YACzB;YACA,OAAO,OAAO;QAClB,EAAE,OAAO,OAAO;YAAE,QAAQ,KAAK,CAAC;QAAQ,SAAU;YAAE,YAAY;QAAQ;IAC5E;IAEA,MAAM,kBAAkB,OAAO,OAAe;QAC1C,cAAc,WAAW,GAAG,CAAC,CAAA;YACzB,IAAI,EAAE,EAAE,KAAK,OAAO;gBAChB,OAAO;oBAAE,GAAG,CAAC;oBAAE,MAAM,EAAE,IAAI,CAAC,MAAM,CAAC,CAAA,IAAK,EAAE,EAAE,KAAK;gBAAO;YAC5D;YACA,OAAO;QACX;QAEA,IAAI;YACA,MAAM,IAAA,mKAAS,EAAC;YAChB,OAAO,OAAO;QAClB,EAAE,OAAO,OAAO;YAAE,QAAQ,KAAK,CAAC;QAAQ;IAC5C;IAEA,qBACI,8OAAC;QAAI,WAAU;;0BACX,8OAAC;gBAAI,WAAU;;kCACX,8OAAC;wBAAG,WAAU;kCAAoC;;;;;;kCAElD,8OAAC;wBAAI,WAAU;;0CACX,8OAAC;gCACG,MAAK;gCACL,aAAY;gCACZ,WAAU;gCACV,OAAO;gCACP,UAAU,CAAC,IAAM,cAAc,EAAE,MAAM,CAAC,KAAK;gCAC7C,WAAW,CAAC,IAAM,EAAE,GAAG,KAAK,WAAW;;;;;;0CAI3C,8OAAC;gCAAI,WAAU;0CACV,OAAO,KAAK,CAAC,GAAG,GAAG,GAAG,CAAC,CAAA,kBACpB,8OAAC;wCAEG,SAAS,IAAM,iBAAiB,EAAE,KAAK;wCACvC,WAAW,CAAC,0DAA0D,EAAE,EAAE,KAAK,KAAK,gBAAgB,sCAAsC,IAAI;wCAC9I,OAAO;4CAAE,iBAAiB,EAAE,KAAK,KAAK,UAAU,UAAU,CAAC,YAAY,EAAE,EAAE,KAAK,CAAC,MAAM,EAAE,EAAE,KAAK,CAAC,CAAC,CAAC;wCAAC;wCACpG,OAAO,EAAE,IAAI;uCAJR,EAAE,KAAK;;;;;;;;;;0CASxB,8OAAC;gCACG,SAAS;gCACT,UAAU;gCACV,WAAU;0CACb;;;;;;;;;;;;;;;;;;0BAMT,8OAAC;gBAAI,WAAU;0BACV,WAAW,GAAG,CAAC,CAAC;oBACb,MAAM,WAAW,OAAO,IAAI,CAAC,CAAA,IAAK,EAAE,KAAK,KAAK,SAAS,KAAK,KAAK,MAAM,CAAC,EAAE;oBAC1E,qBACI,8OAAC,iIAAI;wBAAmB,WAAW,CAAC,0BAA0B,EAAE,UAAU,SAAS,SAAS,MAAM,CAAC,OAAO,CAAC,WAAW,eAAe,IAAI;wBAAE,OAAO;4BAAE,gBAAgB,SAAS,KAAK,KAAK,UAAU,SAAS,KAAK,GAAG;wBAAU;;0CACxN,8OAAC,uIAAU;gCAAC,WAAU;;kDAClB,8OAAC;wCAAI,WAAU;;0DACX,8OAAC,sIAAS;0DAAE,SAAS,IAAI;;;;;;0DACzB,8OAAC;gDAAI,WAAU;0DACV,OAAO,GAAG,CAAC,CAAA,kBACR,8OAAC;wDAEG,SAAS,IAAM,0BAA0B,SAAS,EAAE,EAAE,EAAE,KAAK;wDAC7D,WAAW,CAAC,0DAA0D,EAAE,SAAS,KAAK,KAAK,EAAE,KAAK,GAAG,sCAAsC,IAAI;wDAC/I,OAAO;4DAAE,iBAAiB,EAAE,KAAK,KAAK,UAAU,YAAY,CAAC,YAAY,EAAE,EAAE,KAAK,CAAC,MAAM,EAAE,EAAE,KAAK,CAAC,CAAC,CAAC;wDAAC;wDACtG,OAAO,CAAC,aAAa,EAAE,EAAE,IAAI,EAAE;uDAJ1B,EAAE,KAAK;;;;;;;;;;;;;;;;kDAS5B,8OAAC;wCACG,SAAS,IAAM,qBAAqB,SAAS,EAAE;wCAC/C,WAAU;kDAEV,cAAA,8OAAC,iMAAC;4CAAC,WAAU;;;;;;;;;;;;;;;;;0CAGrB,8OAAC,wIAAW;;kDACR,8OAAC;wCAAI,WAAU;;4CACV,SAAS,IAAI,CAAC,GAAG,CAAC,CAAA,oBACf,8OAAC;oDAAiB,WAAW,CAAC,qEAAqE,EAAE,IAAI,KAAK,IAAI,SAAS,KAAK,EAAE;;sEAC9H,8OAAC;sEAAM,IAAI,IAAI;;;;;;sEACf,8OAAC;4DAAO,SAAS,IAAM,gBAAgB,SAAS,EAAE,EAAE,IAAI,EAAE;4DAAG,WAAU;sEACnE,cAAA,8OAAC,iMAAC;gEAAC,WAAU;;;;;;;;;;;;mDAHX,IAAI,EAAE;;;;;4CAOnB,SAAS,IAAI,CAAC,MAAM,KAAK,mBACtB,8OAAC;gDAAK,WAAU;0DAAuC;;;;;;;;;;;;kDAI/D,8OAAC;wCAAI,WAAU;;0DACX,8OAAC;gDACG,MAAK;gDACL,aAAY;gDACZ,WAAU;gDACV,OAAO,WAAW,CAAC,SAAS,EAAE,CAAC,IAAI;gDACnC,UAAU,CAAC,IAAM,eAAe,CAAA,OAAQ,CAAC;4DAAE,GAAG,IAAI;4DAAE,CAAC,SAAS,EAAE,CAAC,EAAE,EAAE,MAAM,CAAC,KAAK;wDAAC,CAAC;gDACnF,WAAW,CAAC,IAAM,EAAE,GAAG,KAAK,WAAW,aAAa,SAAS,EAAE;;;;;;0DAEnE,8OAAC;gDACG,SAAS,IAAM,aAAa,SAAS,EAAE;gDACvC,WAAU;0DAEV,cAAA,8OAAC,0MAAI;oDAAC,WAAU;;;;;;;;;;;;;;;;;;;;;;;;uBAnDrB,SAAS,EAAE;;;;;gBAyD9B;;;;;;;;;;;;AAIhB"}},
    {"offset": {"line": 597, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/lucide-react/dist/esm/icons/plus.js","sources":["file:///Users/jacklau/Documents/GitHub/Trading-app/node_modules/lucide-react/src/icons/plus.ts"],"sourcesContent":["import createLucideIcon from '../createLucideIcon';\nimport { IconNode } from '../types';\n\nexport const __iconNode: IconNode = [\n  ['path', { d: 'M5 12h14', key: '1ays0h' }],\n  ['path', { d: 'M12 5v14', key: 's699le' }],\n];\n\n/**\n * @component @name Plus\n * @description Lucide SVG icon component, renders SVG Element with children.\n *\n * @preview ![img](data:image/svg+xml;base64,PHN2ZyAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogIHdpZHRoPSIyNCIKICBoZWlnaHQ9IjI0IgogIHZpZXdCb3g9IjAgMCAyNCAyNCIKICBmaWxsPSJub25lIgogIHN0cm9rZT0iIzAwMCIgc3R5bGU9ImJhY2tncm91bmQtY29sb3I6ICNmZmY7IGJvcmRlci1yYWRpdXM6IDJweCIKICBzdHJva2Utd2lkdGg9IjIiCiAgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIgogIHN0cm9rZS1saW5lam9pbj0icm91bmQiCj4KICA8cGF0aCBkPSJNNSAxMmgxNCIgLz4KICA8cGF0aCBkPSJNMTIgNXYxNCIgLz4KPC9zdmc+Cg==) - https://lucide.dev/icons/plus\n * @see https://lucide.dev/guide/packages/lucide-react - Documentation\n *\n * @param {Object} props - Lucide icons props and any valid SVG attribute\n * @returns {JSX.Element} JSX Element\n *\n */\nconst Plus = createLucideIcon('plus', __iconNode);\n\nexport default Plus;\n"],"names":[],"mappings":";;;;;;;;;;;;;AAGO,CAAA,CAAA,CAAA,CAAA,CAAA,CAAM,UAAA,CAAA,CAAA,CAAuB;IAClC;QAAC,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;QAAQ,CAAA;YAAE,GAAG,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;YAAY,CAAA,CAAA,CAAA,CAAA,CAAK,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;QAAA,CAAU;KAAA;IACzC;QAAC,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;QAAQ,CAAA;YAAE,GAAG,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;YAAY,CAAA,CAAA,CAAA,CAAA,CAAK,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;QAAA,CAAU;KAAA;CAC3C;AAaA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAM,IAAA,CAAA,CAAA,KAAO,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,8JAAA,EAAiB,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,EAAQ,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAU,CAAA"}},
    {"offset": {"line": 642, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/lucide-react/dist/esm/icons/x.js","sources":["file:///Users/jacklau/Documents/GitHub/Trading-app/node_modules/lucide-react/src/icons/x.ts"],"sourcesContent":["import createLucideIcon from '../createLucideIcon';\nimport { IconNode } from '../types';\n\nexport const __iconNode: IconNode = [\n  ['path', { d: 'M18 6 6 18', key: '1bl5f8' }],\n  ['path', { d: 'm6 6 12 12', key: 'd8bk6v' }],\n];\n\n/**\n * @component @name X\n * @description Lucide SVG icon component, renders SVG Element with children.\n *\n * @preview ![img](data:image/svg+xml;base64,PHN2ZyAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogIHdpZHRoPSIyNCIKICBoZWlnaHQ9IjI0IgogIHZpZXdCb3g9IjAgMCAyNCAyNCIKICBmaWxsPSJub25lIgogIHN0cm9rZT0iIzAwMCIgc3R5bGU9ImJhY2tncm91bmQtY29sb3I6ICNmZmY7IGJvcmRlci1yYWRpdXM6IDJweCIKICBzdHJva2Utd2lkdGg9IjIiCiAgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIgogIHN0cm9rZS1saW5lam9pbj0icm91bmQiCj4KICA8cGF0aCBkPSJNMTggNiA2IDE4IiAvPgogIDxwYXRoIGQ9Im02IDYgMTIgMTIiIC8+Cjwvc3ZnPgo=) - https://lucide.dev/icons/x\n * @see https://lucide.dev/guide/packages/lucide-react - Documentation\n *\n * @param {Object} props - Lucide icons props and any valid SVG attribute\n * @returns {JSX.Element} JSX Element\n *\n */\nconst X = createLucideIcon('x', __iconNode);\n\nexport default X;\n"],"names":[],"mappings":";;;;;;;;;;;;;AAGO,CAAA,CAAA,CAAA,CAAA,CAAA,CAAM,UAAA,CAAA,CAAA,CAAuB;IAClC;QAAC,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;QAAQ,CAAA;YAAE,GAAG,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;YAAc,CAAA,CAAA,CAAA,CAAA,CAAK,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;QAAA,CAAU;KAAA;IAC3C;QAAC,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;QAAQ,CAAA;YAAE,GAAG,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;YAAc,CAAA,CAAA,CAAA,CAAA,CAAK,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;QAAA,CAAU;KAAA;CAC7C;AAaA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAM,CAAA,CAAA,CAAA,KAAI,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,8JAAA,EAAiB,CAAA,CAAA,CAAA,EAAK,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAU,CAAA"}},
    {"offset": {"line": 687, "column": 0}, "map": {"version":3,"sources":["file:///Users/jacklau/Documents/GitHub/Trading-app/node_modules/next/src/build/webpack/loaders/next-flight-loader/action-client-wrapper.ts"],"sourcesContent":["// This file must be bundled in the app's client layer, it shouldn't be directly\n// imported by the server.\n\nexport { callServer } from 'next/dist/client/app-call-server'\nexport { findSourceMapURL } from 'next/dist/client/app-find-source-map-url'\n\n// A noop wrapper to let the Flight client create the server reference.\n// See also: https://github.com/facebook/react/pull/26632\n// eslint-disable-next-line import/no-extraneous-dependencies\nexport { createServerReference } from 'react-server-dom-webpack/client'\n"],"names":["callServer","createServerReference","findSourceMapURL"],"mappings":"AAAA,gFAAgF;AAChF,0BAA0B;;;;;;;;;;;;;;;;IAEjBA,UAAU,EAAA;eAAVA,eAAAA,UAAU;;IAMVC,qBAAqB,EAAA;eAArBA,QAAAA,qBAAqB;;IALrBC,gBAAgB,EAAA;eAAhBA,qBAAAA,gBAAgB;;;+BADE;qCACM;wBAKK","ignoreList":[0]}}]
}